# Huffman_Coding_Project
Author - Akshit Kaushal

****ABOUT THE PROJECT****
This project is a C++ implementation of the Huffman coding algorithm, which is a lossless data compression technique. The program can be used to compress and decompress files of various types, achieving significant reductions in file size compared to the original.

****DEPENDENCIES****
This program does not have any dependencies on external libraries. It uses only the standard C++ libraries.

****HOW TO USE****
1) Compressing a file
To compress a file, run the following command in your terminal to create an executable file:

g++ encode.cpp huffman.cpp -o main

Now run this command : 
./main inputFile.txt compressedFile.huf

where inputFile is file you want to compress, and compressedFile is your compressed File.

2) Decompressing a file
To decompress a compressed file, run the following command in your terminal:

g++ decode.cpp huffman.cpp -o main

Now run this command:
./main compressedFile.huf outputFile.txt
where compressedFile is the compressed file, and outpuFile is the file where you want to save the decompressed file.

****IMPLEMENTATION DETAILS****
The program uses a binary tree to construct the Huffman code for the given input file. The tree is built by first constructing a min-heap of all the characters in the file based on their frequency of occurrence. The two characters with the lowest frequency are then combined to form a new node, which is inserted back into the heap. This process is repeated until the heap contains only one node, which represents the root of the Huffman tree.

Once the Huffman tree is constructed, the program generates a code for each character by traversing the tree from the root to the leaf node corresponding to the character. The code is generated by assigning a '0' to each left traversal and a '1' to each right traversal. The codes are then written to an output file along with the encoded data.

During the decompression process, the program reads the Huffman tree from the input file, constructs the tree, and then traverses the tree to decode the data.
